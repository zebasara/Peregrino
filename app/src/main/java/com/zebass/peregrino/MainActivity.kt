package com.zebass.peregrino

import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import androidx.navigation.findNavController
import androidx.work.Configuration
import androidx.work.WorkManager
import com.zebass.peregrino.databinding.ActivityMainBinding
import kotlinx.coroutines.launch

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private lateinit var sharedPreferences: SharedPreferences

    companion object {
        private const val TAG = "MainActivity"
        private const val NOTIFICATION_PERMISSION_REQUEST_CODE = 1001
    }

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(TAG, "üöÄ MainActivity created")

        sharedPreferences = getSharedPreferences("user_prefs", Context.MODE_PRIVATE)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        checkAndRequestNotificationPermission()
        initializeWorkManager()
        scheduleSyncWork()
        setupNavigation()
        requestLocationPermissions()
    }

    private fun requestLocationPermissions() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val permissions = arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION
            )

            requestPermissions(permissions, 1001)
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == 1001) {
            val allGranted = grantResults.all { it == PackageManager.PERMISSION_GRANTED }
            if (allGranted) {
                Log.d(TAG, "‚úÖ Todos los permisos de ubicaci√≥n concedidos")
            } else {
                Log.e(TAG, "‚ùå Permisos de ubicaci√≥n denegados - GPS no funcionar√°")
            }
        }
        when (requestCode) {
            NOTIFICATION_PERMISSION_REQUEST_CODE -> {
                if (grantResults.isNotEmpty() &&
                    grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    Log.d(TAG, "‚úÖ Permiso de notificaciones concedido")
                } else {
                    Log.w(TAG, "‚ùå Permiso de notificaciones denegado")
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        if (!shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {
                            showPermissionSettingsDialog()
                        }
                    }
                }
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    private fun checkAndRequestNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            when {
                ContextCompat.checkSelfPermission(
                    this,
                    Manifest.permission.POST_NOTIFICATIONS
                ) == PackageManager.PERMISSION_GRANTED -> {
                    Log.d(TAG, "‚úÖ Permiso de notificaciones ya concedido")
                }

                shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
                    showPermissionExplanationDialog()
                }

                else -> {
                    ActivityCompat.requestPermissions(
                        this,
                        arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                        NOTIFICATION_PERMISSION_REQUEST_CODE
                    )
                }
            }
        }
    }

    private fun showPermissionExplanationDialog() {
        AlertDialog.Builder(this)
            .setTitle("Permiso necesario")
            .setMessage("Este permiso es necesario para mostrarte notificaciones importantes sobre el estado del rastreo GPS.")
            .setPositiveButton("Entendido") { _, _ ->
                ActivityCompat.requestPermissions(
                    this,
                    arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                    NOTIFICATION_PERMISSION_REQUEST_CODE
                )
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }

    private fun showPermissionSettingsDialog() {
        AlertDialog.Builder(this)
            .setTitle("Permiso requerido")
            .setMessage("Has denegado el permiso permanentemente. Por favor, habil√≠talo manualmente en Configuraci√≥n -> Aplicaciones -> [Esta app] -> Permisos")
            .setPositiveButton("Abrir configuraci√≥n") { _, _ ->
                openAppSettings()
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }

    private fun openAppSettings() {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = android.net.Uri.fromParts("package", packageName, null)
        }
        startActivity(intent)
    }

    private fun initializeWorkManager() {
        try {
            WorkManager.getInstance(this)
            Log.d(TAG, "‚úÖ WorkManager ya est√° inicializado")
        } catch (e: IllegalStateException) {
            val config = Configuration.Builder()
                .setMinimumLoggingLevel(Log.INFO)
                .build()
            WorkManager.initialize(this, config)
            Log.d(TAG, "‚úÖ WorkManager inicializado")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error inicializando WorkManager", e)
        }
    }

    private fun scheduleSyncWork() {
        lifecycleScope.launch {
            try {
                SyncWorker.schedulePeriodicSync(applicationContext, 15)
                Log.d(TAG, "‚úÖ Sincronizaci√≥n peri√≥dica programada")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error programando trabajo de sincronizaci√≥n", e)
            }
        }
    }

    private fun setupNavigation() {
        try {
            val navController = findNavController(R.id.nav_host_fragment_content_main)

            navController.addOnDestinationChangedListener { _, destination, _ ->
                Log.d(TAG, "üìç Navigation destination changed to: ${destination.id}")

                when (destination.id) {
                    R.id.FirstFragment -> {
                        Log.d(TAG, "üìç Now in FirstFragment (Login)")
                        supportActionBar?.hide()
                    }
                    R.id.SecondFragment -> {
                        Log.d(TAG, "üìç Now in SecondFragment (Main)")
                        supportActionBar?.show()
                    }
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error setting up navigation", e)
        }
    }

    // ‚úÖ MEJORAR MANEJO DE BACK BUTTON PARA NO CERRAR WEBSOCKET
    override fun onBackPressed() {
        try {
            val navController = findNavController(R.id.nav_host_fragment_content_main)

            when (navController.currentDestination?.id) {
                R.id.FirstFragment -> {
                    Log.d(TAG, "‚¨ÖÔ∏è Back pressed in FirstFragment - exiting app")
                    finishAffinity()
                }
                R.id.SecondFragment -> {
                    Log.d(TAG, "‚¨ÖÔ∏è Back pressed in SecondFragment - showing logout confirmation")
                    showLogoutConfirmation()
                }
                else -> {
                    super.onBackPressed()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error handling back press", e)
            super.onBackPressed()
        }
    }

    // ‚úÖ NUEVA FUNCI√ìN: MOSTRAR CONFIRMACI√ìN DE LOGOUT SIN CERRAR WEBSOCKET
    private fun showLogoutConfirmation() {
        AlertDialog.Builder(this)
            .setTitle("Cerrar Sesi√≥n")
            .setMessage("¬øEst√°s seguro que deseas cerrar la sesi√≥n?\n\nNota: El tracking GPS se mantendr√° en segundo plano si est√° activo.")
            .setPositiveButton("Cerrar Sesi√≥n") { _, _ ->
                performLogout()
            }
            .setNegativeButton("Cancelar") { dialog, _ ->
                dialog.dismiss()
            }
            .setNeutralButton("Minimizar App") { _, _ ->
                moveTaskToBack(true)
            }
            .show()
    }

    private fun performLogout() {
        try {
            Log.d(TAG, "üö™ Performing logout from MainActivity")

            // ‚úÖ LIMPIAR SESI√ìN PERO MANTENER WEBSOCKET SI HAY TRACKING ACTIVO
            with(sharedPreferences.edit()) {
                // ‚úÖ MANTENER ALGUNOS DATOS CR√çTICOS PARA EL SERVICIO
                val hasActiveTracking = sharedPreferences.getBoolean("is_sharing_location", false)
                val deviceId = sharedPreferences.getString("associated_device_unique_id", null)

                clear()

                // ‚úÖ RESTAURAR DATOS CR√çTICOS SI HAY TRACKING ACTIVO
                if (hasActiveTracking && !deviceId.isNullOrEmpty()) {
                    putBoolean("is_sharing_location", true)
                    putString("associated_device_unique_id", deviceId)
                    Log.d(TAG, "üì± Keeping essential data for active location sharing")
                }

                apply()
            }

            // ‚úÖ NAVEGAR A LOGIN
            val navController = findNavController(R.id.nav_host_fragment_content_main)
            navController.popBackStack(R.id.FirstFragment, false)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error performing logout", e)
            recreate()
        }
    }

    // ‚úÖ MEJORAR onResume PARA MANTENER CONTINUIDAD DEL WEBSOCKET
    override fun onResume() {
        super.onResume()

        try {
            val token = sharedPreferences.getString("jwt_token", null)
            val navController = findNavController(R.id.nav_host_fragment_content_main)

            Log.d(TAG, "‚ñ∂Ô∏è MainActivity resumed - Token exists: ${token != null}, Current: ${navController.currentDestination?.id}")

            // ‚úÖ VERIFICAR CONSISTENCIA DE NAVEGACI√ìN
            if (token == null && navController.currentDestination?.id == R.id.SecondFragment) {
                Log.w(TAG, "‚ö†Ô∏è No token but in SecondFragment - redirecting to login")
                navController.popBackStack(R.id.FirstFragment, false)
            }

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error in onResume", e)
        }
    }

    // ‚úÖ NUEVA FUNCI√ìN: MANEJO DE onPause PARA WEBSOCKET PERSISTENTE
    override fun onPause() {
        super.onPause()
        Log.d(TAG, "‚è∏Ô∏è MainActivity paused")

        // ‚úÖ NO hacer nada especial aqu√≠ para mantener WebSocket vivo
        // El WebSocket debe continuar funcionando en background
    }

    // ‚úÖ NUEVA FUNCI√ìN: MANEJO DE onStop PARA WEBSOCKET PERSISTENTE
    override fun onStop() {
        super.onStop()
        Log.d(TAG, "‚èπÔ∏è MainActivity stopped")

        // ‚úÖ App va a background pero WebSocket debe mantenerse
        // Solo log para debug, no cerrar nada
    }

    // ‚úÖ NUEVA FUNCI√ìN: MANEJO DE onDestroy PARA CLEANUP FINAL
    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "üóëÔ∏è MainActivity destroyed")

        // ‚úÖ SOLO hacer cleanup final si la app se est√° cerrando completamente
        if (isFinishing) {
            Log.d(TAG, "üõë App finishing - final cleanup")

            // ‚úÖ Aqu√≠ se podr√≠a hacer cleanup final si es necesario
            // Pero generalmente el WebSocket debe sobrevivir para servicios en background
        }
    }

    // ‚úÖ FUNCI√ìN AUXILIAR PARA VERIFICAR SI HAY SERVICIOS ACTIVOS
    private fun hasActiveBackgroundServices(): Boolean {
        val hasLocationSharing = sharedPreferences.getBoolean("is_sharing_location", false)
        val hasActiveTracking = sharedPreferences.contains("associated_device_unique_id")

        return hasLocationSharing || hasActiveTracking
    }

    // ‚úÖ FUNCI√ìN PARA MOSTRAR ESTADO DE SERVICIOS EN BACKGROUND
    private fun showBackgroundServicesStatus() {
        val hasLocationSharing = sharedPreferences.getBoolean("is_sharing_location", false)
        val deviceId = sharedPreferences.getString("associated_device_unique_id", null)

        val statusMessage = buildString {
            appendLine("üì± Estado de Servicios en Background:")
            appendLine("")

            if (hasLocationSharing) {
                appendLine("üåç ‚úÖ Compartir ubicaci√≥n: ACTIVO")
            } else {
                appendLine("üåç ‚≠ï Compartir ubicaci√≥n: INACTIVO")
            }

            if (!deviceId.isNullOrEmpty()) {
                appendLine("üìç ‚úÖ Tracking GPS: ACTIVO")
                appendLine("   üì± Dispositivo: $deviceId")
            } else {
                appendLine("üìç ‚≠ï Tracking GPS: INACTIVO")
            }

            appendLine("")
            if (hasLocationSharing || !deviceId.isNullOrEmpty()) {
                appendLine("‚ÑπÔ∏è Los servicios continuar√°n funcionando en segundo plano")
            } else {
                appendLine("‚ÑπÔ∏è No hay servicios activos en segundo plano")
            }
        }

        AlertDialog.Builder(this)
            .setTitle("Estado de Servicios")
            .setMessage(statusMessage)
            .setPositiveButton("Entendido", null)
            .show()
    }

    // ‚úÖ AGREGAR MEN√ö DE OPCIONES SI ES NECESARIO
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.main_menu, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_services_status -> {
                showBackgroundServicesStatus()
                true
            }
            R.id.action_force_reconnect -> {
                // ‚úÖ Enviar broadcast para forzar reconexi√≥n WebSocket
                val intent = Intent("com.peregrino.FORCE_WEBSOCKET_RECONNECT")
                sendBroadcast(intent)

                Toast.makeText(this, "üîÑ Forzando reconexi√≥n WebSocket...", Toast.LENGTH_SHORT).show()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
}